
# coding: utf-8

# In[1]:


import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import scipy.signal as signal
import random
import keras
from keras.callbacks import ModelCheckpoint, EarlyStopping
from sklearn.model_selection import train_test_split
from keras.models import Sequential, load_model
from keras.layers import Dense
from keras.wrappers.scikit_learn import KerasRegressor
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
import utils
import h5py
import time
from sklearn.preprocessing import MinMaxScaler

from numpy.random import seed
seed(1)
from tensorflow import set_random_seed
set_random_seed(1)
'''
Based on work by Federico De Guio: https://github.com/deguio/ML4DQM/blob/master/notebooks/Semi_Supervised/AE_ssl_random_hotdead_size.ipynb
See: https://indico.cern.ch/event/783825/contributions/3261553/attachments/1789464/2914642/hcaldpg_fpga_ml_reco_01feb2019.pdf
for possible implementation into FPGA
'''


# In[2]:


def plot_loss(data, title,yscale="linear"):     
    """ Plots the training and validation loss yscale can be: linear,log,symlog """
    plt.figure()
    plt.xlabel("Epoch")
    plt.ylabel("Loss")
    plt.title(title)
    plt.plot(data.history["loss"])#, linestyle=line_styles[0], color=color_palette["Indigo"][900], linewidth=3)
    plt.plot(data.history["val_loss"])#, linestyle=line_styles[2], color=color_palette["Teal"][300], linewidth=3)
    plt.legend(["Train", "Validation"])#, loc="upper right", frameon=False)
    plt.yscale(yscale)
    plt.show();


# In[3]:


class Pulse:
    '''
    A class that generates a Pulse that includes both Cerenkov and Scintillation Pulse. The pulse is randomly generated 
    through the use of a probability density function that is generated by the given parameters.
    The pulse has 512 samples and is identifiable by 3 parameters:
        1) ratio: If ratio is positive, it is the ratio of the Area of Cernekov:Area of Scintillation. 
                  If ratio is negative, it is the ratio of the Area of Scintillation:Area of Cerenkov
                
        This is altered by changing the height of the Cerenkov pulse (Cerenkov Radiation).
        
        
        2) separation: Time between the two pulses
       
    '''
    
    
    
    def __init__(self,ratio, scint_decay):
        self.start=10
        self.rise=0.05
        self.cerenkov_decay=2.5
        self.scint_decay=scint_decay
        
        self.end_time=250
        self.timesteps=100
        self.t=np.linspace(0,self.end_time,self.timesteps)
        self.bin_number=100
        

        if ratio>0:
            self.ratio=ratio
        else:
            self.ratio=-(1/ratio)
            
        
        self.cerenkov_strength=self.ratio
        #self.cerenkov_percent=self.ratio/(self.ratio+1)
        #self.scint_percent=1/(self.ratio+1)
        #self.interp=self.interpolator()
        self.cerenkov_area=sp.integrate.quad(self.cerenkov_scaled, self.start, self.end_time)
        self.scint_area=sp.integrate.quad(self.scintillation_normalized, self.start, self.end_time)
        
        self.cerenkov_percent=(self.cerenkov_area[0])/(self.cerenkov_area[0]+self.scint_area[0])
        self.scint_percent=(self.scint_area[0])/(self.cerenkov_area[0]+self.scint_area[0])
 
    def cerenkov(self,t):
        return (1-np.exp(-((t-self.start)/self.rise)))*(np.exp(-((t-self.start)/self.cerenkov_decay)))

    def scintillation(self, t):
        return (1-np.exp(-((t-self.start)/self.rise)))*(np.exp(-((t-self.start)/self.scint_decay)))
    
    def cerenkov_scaled(self, t):
        cerenkov=self.cerenkov(t)
        norm=sp.integrate.quad(self.cerenkov, self.start, self.end_time)
        return (1/norm[0])*self.cerenkov_strength*cerenkov
    
    def scintillation_normalized(self, t):
        scint=self.scintillation(t)
        norm=sp.integrate.quad(self.scintillation, self.start, self.end_time)
        return (1/norm[0])*scint


    def pulse_func_helper(self, time):
        if time<self.start:
            return 0
        else:
            return self.cerenkov_scaled(time) + self.scintillation_normalized(time) 
    
    
    def pulse_func(self, t):
        pulse=[]
                        
        for time in t:
            pulse.append(self.pulse_func_helper(time))
        return np.asarray(pulse)


    def randomValues(self,number):
        val=[]
        for x in range(number):
            val.append(random.random())
        return val

    
    def graph_both_pulses(self):
        t=np.arange(self.start,self.end_time,self.timestep)
        plt.figure()
        plt.plot(t, self.cerenkov_scaled(t), c='r', label="cerenkov")
        plt.plot(t, self.scintillation_normalized(t), label='scintillation')
        plt.xlabel("Time (ns)")
        plt.title("Pulse with ratio "+ str(self.ratio)+ " and scint decay "+str(self.scint_decay))
        plt.legend()
    
    def final_pdf(self, t):
        radiation=self.pulse_func(t)
        norm=np.trapz(radiation, self.t)
        return (1/norm)*radiation
    
    def graph_pdf(self):
        plt.figure()
        plt.plot(self.t, self.final_pdf(self.t))
        plt.xlabel("Time (ns)")
        plt.title("Pulse with ratio "+ str(self.ratio)+ " and scint decay "+str(self.scint_decay))

    
    def output(self):
        vals=self.final_pdf(self.t)
        #vals_max=max(vals)
        #output=vals*(1/vals_max)
        #return output, self.cerenkov_percent, self.scint_percent
        
        return vals, self.cerenkov_percent, self.scint_percent

    
    '''
    DEPRECAYED FUNCTIONS
    def final_distribution(self):
        cumul=self.final_cdf(self.t)
        hits=self.photoelectrons
        #print(hits)
        rand=self.randomValues(hits)
        #print(rand)
        interp=sp.interpolate.interp1d(cumul,self.t, fill_value="extrapolate")
        vals=interp(rand)
        #print(vals)
        return vals
        
    def histogram_generator(self):
        data=self.final_distribution()
        hist, bin_edges=np.histogram(data, bins=self.bin_number, range=(0,self.end_time))
        #print(bin_edges)
        return hist
    
    def output(self):
        
        
        return self.histogram_generator(), self.cerenkov_percent, self.scint_percent
    '''
    


# In[4]:


class PulseLibrary:
    '''
    Creates a list of pulses with the attached ratio.
    labels has form of ratioXXXscint_decayXXeventXX
    '''
    
    def __init__(self, seed, name, ratios=[1],scint_decays=[50]):
        np.random.seed(seed)
        self.name=name +'.hdf5'
        self.scint_decays=scint_decays
        self.ratios=ratios
        
        self.labels=[]
        self.pulses=[]
        self.inputs=[]
        self.outputs=[]
        
        
        
        file=h5py.File(self.name, 'w')
        
        for ratio in self.ratios:
            for scint_decay in self.scint_decays:
                pulse=Pulse( ratio, scint_decay)
                
                group_name="ratio"+str(ratio)+"scintdecay"+str(scint_decay)
                
                group = file.create_group(group_name)
                
                
                    
                self.pulses.append(pulse)
                ins, out1, out2=pulse.output()
                outs=[out1, out2]
                 
                 
                label="ratio"+str(ratio)+"scintdecay"+str(scint_decay)
                self.labels.append(label)
                self.inputs.append(ins)
                self.outputs.append(outs)
                 
                subgroup=group.create_group(label)
                    
                    
                d1 = subgroup.create_dataset(label+'input', data=ins)
                d2 = subgroup.create_dataset(label+'output', data=outs)
                    
        
        file.close()
    
    def get_inputs(self):
        return np.asarray(self.inputs)
    
    def get_outputs(self):
        return np.asarray(self.outputs)
    
    def get_labels(self):
        return self.labels
    
    def get_pulses(self):
        return np.asarray(self.pulses)



# In[5]:


def model_creator():
    model = Sequential()
    #model.add(Dense(50,  input_shape=(100,), kernel_initializer='normal', activation='relu'))
    model.add(Dense(10,  input_shape=(100,), kernel_initializer='normal', activation='relu'))
    model.add(Dense(2, kernel_initializer='normal', activation='relu'))
# Compile model
    model.compile(loss='mean_squared_error', optimizer='adam')
    return model

def model_trainer(pulse_library, model_name):
    model=model_creator()
    file=h5py.File(pulse_library, 'r')
    X=[]
    Y=[]
    for groups in file.values():
        for subgroup in groups.values():
            for event in subgroup.values():

                if event.name[-5:]=="input":
                    X.append(event[:])
                elif event.name[-6:]=="output":
                    Y.append(event[:])
    file.close()    
    X=np.asarray(X)

    Y=np.asarray(Y)
    Xtrain, Xval, Ytrain, Yval = train_test_split(X, Y, test_size=0.2, random_state=42)
    #checkpointer = ModelCheckpoint(filepath=model_name+"weights.hdf5",verbose=3, save_best_only=True)
    earlystop= EarlyStopping(monitor='val_loss', min_delta=0, patience=100 ,verbose=1, mode='auto')
    history=model.fit(Xtrain,Ytrain,epochs=700,verbose=1
                             ,validation_data=(Xval,Yval)
                             ,shuffle=True, batch_size=32
                             ,callbacks=[earlystop])
    model.save(model_name)
    return model, history

def model_verifier(pulse_library, model_name, ratios, scint_decays):
    model=load_model(model_name)
    file=h5py.File(pulse_library, 'r')
    X=[]
    Y=[]
    labels=[]
    
    for ratio in ratios:
        for scint_decay in scint_decays:
            tempX=[]
            tempY=[]
            templabels=[]
            
            label="/ratio"+str(ratio)+"scintdecay"+str(scint_decay)+"/ratio"+str(ratio)+"scintdecay"+str(scint_decay)+"/ratio"+str(ratio)+"scintdecay"+str(scint_decay)
                #print(label)
            Xdata=file[label+"input"][:]
            Ydata=file[label+"output"][:]
            tempX.append(Xdata)
            tempY.append(Ydata)
            templabels.append(label)
            X.append(tempX)
            Y.append(tempY)
            labels.append(templabels)
    
    file.close()
    X=np.asarray(X)
    Y=np.asarray(Y)
    results=[]
    for x in X:
        prediction=model.predict(x)
        results.append(prediction)

    results=np.array(results)
    #results=model.predict(X)
    return results, Y, labels
    
    
    '''
    deprecated
    for groups in file.values():
        tempX=[]
        tempY=[]
        templabels=[]
        for subgroup in groups.values():
            
            for event in subgroup.values():
                if event.name[-5:]=="input":
                    tempX.append(event)
                    templabels.append(event.name)
                elif event.name[-6:]=="output":
                    tempY.append(event)
        X.append(tempX)
        Y.append(tempY)
        labels.append(templabels)
            
    X=np.asarray(X)
    Y=np.asarray(Y)
    results=[]
    for x in X:
        prediction=model.predict(x)
        results.append(prediction)
    results=np.array(results)
    #results=model.predict(X)
    return results, Y, labels
    '''


# In[6]:


training_seed=7
testing_seed=8
nn1_scint_decays_train=np.linspace(15,50,100)
nn1_ratios_train=np.linspace(-25,25,100)


nn1_scint_decays_test=np.linspace(15,50,20)
nn1_ratios_test=np.linspace(-25,25,20)





# In[7]:



train_library2=PulseLibrary(training_seed,"PDFsOnlyTrainingLibrary", nn1_ratios_train, nn1_scint_decays_train)
